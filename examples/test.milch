(let! compose (\[f g]
    (\[x] (f (g x)))))

((compose (+ 1) (+ 2)) 3)

(let! id (\[a] a))

(let! mod (\[n k]
    (- n (* k (/ n k)))))

(let! not (\[b]
    (match b
        true false
        false true)))

(let! is-even (\[n]
    (match (mod n 2)
        0 true
        1 false)))

(let! is-odd (compose not is-even))

;; map :: (a -> b) -> [a] -> [b]
(let! map (\[f lst]
    (match lst
        []
            []
        otherwise
            (prepend (f (head lst)) (map f (tail lst))))))

(map (+ 1) [1 2 3])

;; foldr :: (a -> b -> b) -> b -> [a] -> b
(let! foldr (\[f accumulator lst]
    (match lst
        []
            accumulator
        otherwise
            (f (head lst) (foldr f accumulator (tail lst))))))

(foldr + 0 [1 2 3])

;; filter :: (a -> Bool) -> [a] -> [a]
(let! filter (\[pred lst]
    (match lst
        [] []
        otherwise (match (pred (head lst))
            true
                (prepend (head lst) (filter pred (tail lst)))
            false
                (filter pred (tail lst))))))

(filter is-even [0 1 2 3 4 5])

(let! reverse_ (\[v a]
    (let! lazy x (head v))
    (let! lazy xs (tail v))
    (let! lazy xa (prepend x a))
    (match v
        [] a
        _  (reverse_ xs xa))))

(let! reverse (\[v]
    (reverse_ v [])))

(reverse [1 2 3])

(let! flow (\[fs] (foldr compose id (reverse fs))))
(let! pipe (\[x fs] ((flow fs) x)))

(pipe 10 [(+ 1) (+ 2)])
